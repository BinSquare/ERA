---
title: HTTP Server Mode
description: Run ERA Agent as a local HTTP API server
---

Run ERA Agent as an HTTP API server for programmatic access to all features. Perfect for integrations, custom frontends, and self-hosted deployments.

## Quick Start

### Start the Server

```bash
# Default port 8080
./agent server

# Custom port
PORT=9000 ./agent server

# With debug logging
AGENT_LOG_LEVEL=debug ./agent server

# Or use explicit address
./agent server --addr :9000
```

The server will start and listen on `http://localhost:8080` (or configured port)

### Test the Server

```bash
curl http://localhost:8080/api/vm/list
```

Should return a JSON response with an empty list of VMs.

## API Endpoints

The HTTP server exposes VM management APIs. See the [API Reference](/docs/api-reference) for complete documentation.

### Quick Examples

**Create VM:**
```bash
curl -X POST http://localhost:8080/api/vm/create \
  -H "Content-Type: application/json" \
  -d '{
    "language": "python",
    "cpu": 2,
    "memory": 512,
    "network": "allow_all",
    "persist": true
  }'
```

**Execute Code in VM:**
```bash
curl -X POST http://localhost:8080/api/vm/execute \
  -H "Content-Type: application/json" \
  -d '{
    "vm_id": "abc123",
    "command": "python -c \"print(\\\"Hello from VM!\\\")\"",
    "timeout": 30
  }'
```

**Execute Code in Temporary VM:**
```bash
curl -X POST http://localhost:8080/api/vm/temp \
  -H "Content-Type: application/json" \
  -d '{
    "language": "python",
    "command": "print(2 + 2)",
    "cpu": 1,
    "memory": 256
  }'
```

**List VMs:**
```bash
curl http://localhost:8080/api/vm/list
```

## Configuration

### Environment Variables

```bash
# Server Configuration
export PORT=8080                    # Server port (default: 8080)
export AGENT_MODE=http              # Auto-start as HTTP server

# Security
export ERA_API_KEY=your-secret-key  # API key for authentication (optional)

# Logging
export AGENT_LOG_LEVEL=info         # Log level: debug, info, warn, error

# Storage
export AGENT_STATE_DIR=/custom/path # State directory

# Then start
./agent
```

### Systemd Service (Linux)

Create `/etc/systemd/system/era-agent.service`:

```ini
[Unit]
Description=ERA Agent HTTP Server
After=network.target

[Service]
Type=simple
User=era-agent
WorkingDirectory=/opt/era-agent
Environment="PORT=8080"
Environment="AGENT_LOG_LEVEL=info"
Environment="AGENT_STATE_DIR=/var/lib/era-agent"
ExecStart=/opt/era-agent/agent server
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
```

Enable and start:

```bash
sudo systemctl daemon-reload
sudo systemctl enable era-agent
sudo systemctl start era-agent
sudo systemctl status era-agent
```

### Launchd Service (macOS)

Create `~/Library/LaunchAgents/com.era-agent.server.plist`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.era-agent.server</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/agent</string>
        <string>server</string>
    </array>
    <key>EnvironmentVariables</key>
    <dict>
        <key>PORT</key>
        <string>8080</string>
        <key>AGENT_LOG_LEVEL</key>
        <string>info</string>
    </dict>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>/usr/local/var/log/era-agent.log</string>
    <key>StandardErrorPath</key>
    <string>/usr/local/var/log/era-agent-error.log</string>
</dict>
</plist>
```

Load the service:

```bash
launchctl load ~/Library/LaunchAgents/com.era-agent.server.plist
launchctl start com.era-agent.server
```

## Client Libraries

### Python

```python
import requests

class ERAAgentClient:
    def __init__(self, base_url="http://localhost:8080"):
        self.base_url = base_url

    def create_vm(self, language, **kwargs):
        """Create a VM."""
        response = requests.post(
            f"{self.base_url}/api/vm/create",
            json={"language": language, **kwargs}
        )
        return response.json()

    def execute_in_vm(self, vm_id, command, **kwargs):
        """Execute command in existing VM."""
        response = requests.post(
            f"{self.base_url}/api/vm/execute",
            json={"vm_id": vm_id, "command": command, **kwargs}
        )
        return response.json()

    def execute_temp(self, language, command, **kwargs):
        """Execute command in temporary VM."""
        response = requests.post(
            f"{self.base_url}/api/vm/temp",
            json={"language": language, "command": command, **kwargs}
        )
        return response.json()

    def list_vms(self):
        """List all VMs."""
        response = requests.get(f"{self.base_url}/api/vm/list")
        return response.json()

# Usage
client = ERAAgentClient()

# Quick execution in temporary VM
result = client.execute_temp("python", "print('Hello!')")
print(result)

# VM-based execution
vm = client.create_vm("python", cpu=2, memory=512)
vm_id = vm["data"]["id"]

result = client.execute_in_vm(vm_id, "python -c 'x = 42; print(x)'")
print(result)
```

### Node.js

```javascript
class ERAAgentClient {
    constructor(baseURL = 'http://localhost:8080') {
        this.baseURL = baseURL;
    }

    async createVM(language, options = {}) {
        const response = await fetch(`${this.baseURL}/api/vm/create`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ language, ...options })
        });
        return response.json();
    }

    async executeInVM(vmId, command, options = {}) {
        const response = await fetch(`${this.baseURL}/api/vm/execute`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ vm_id: vmId, command, ...options })
        });
        return response.json();
    }

    async executeTemp(language, command, options = {}) {
        const response = await fetch(`${this.baseURL}/api/vm/temp`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ language, command, ...options })
        });
        return response.json();
    }

    async listVMs() {
        const response = await fetch(`${this.baseURL}/api/vm/list`);
        return response.json();
    }
}

// Usage
const client = new ERAAgentClient();

// Quick execution
const result = await client.executeTemp("python", "print('Hello!')");
console.log(result);

// VM-based execution
const vm = await client.createVM("python", { cpu: 2, memory: 512 });
const vmId = vm.data.id;

const result2 = await client.executeInVM(vmId, "python -c 'x = 42; print(x)'");
console.log(result2);
```

### Go

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type CreateVMRequest struct {
    Language string `json:"language"`
    CPU      int    `json:"cpu"`
    Memory   int    `json:"memory"`
    Network  string `json:"network"`
    Persist  bool   `json:"persist"`
}

type ExecuteInVMRequest struct {
    VMID    string `json:"vm_id"`
    Command string `json:"command"`
    Timeout int    `json:"timeout"`
}

type ERAAgentClient struct {
    BaseURL string
}

func NewClient(baseURL string) *ERAAgentClient {
    return &ERAAgentClient{BaseURL: baseURL}
}

func (c *ERAAgentClient) CreateVM(req CreateVMRequest) (map[string]interface{}, error) {
    data, _ := json.Marshal(req)
    resp, err := http.Post(
        c.BaseURL+"/api/vm/create",
        "application/json",
        bytes.NewBuffer(data),
    )
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var result map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&result)
    return result, nil
}

func (c *ERAAgentClient) ExecuteInVM(req ExecuteInVMRequest) (map[string]interface{}, error) {
    data, _ := json.Marshal(req)
    resp, err := http.Post(
        c.BaseURL+"/api/vm/execute",
        "application/json",
        bytes.NewBuffer(data),
    )
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var result map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&result)
    return result, nil
}

// Usage
func main() {
    client := NewClient("http://localhost:8080")

    vm, _ := client.CreateVM(CreateVMRequest{
        Language: "python",
        CPU:      1,
        Memory:   256,
        Network:  "none",
        Persist:  false,
    })
    fmt.Println(vm)
}
```

## Reverse Proxy Setup

### Nginx

```nginx
server {
    listen 80;
    server_name era-agent.example.com;

    location / {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        # Timeouts for long-running code
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
    }
}
```

### Caddy

```
era-agent.example.com {
    reverse_proxy localhost:8080
}
```

### Apache

```apache
<VirtualHost *:80>
    ServerName era-agent.example.com

    ProxyPreserveHost On
    ProxyPass / http://localhost:8080/
    ProxyPassReverse / http://localhost:8080/

    ProxyTimeout 300
</VirtualHost>
```

## Security

### Authentication

The local HTTP server includes optional built-in authentication via the ERA_API_KEY environment variable. When set, API endpoints (those starting with `/api/`) require authentication via the Authorization header:

```
Authorization: Bearer <your-api-key>
```

Web interface routes (`/`, `/index.html`, `/web/`) do not require authentication.

```bash
# With authentication
export ERA_API_KEY=your-secret-key
./agent server

# Test with authentication
curl -H "Authorization: Bearer your-secret-key" \
  http://localhost:8080/api/vm/list
```

### Firewall

Restrict access to localhost only:

```bash
# iptables (Linux)
sudo iptables -A INPUT -p tcp --dport 8080 -s 127.0.0.1 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 8080 -j DROP

# pf (macOS)
# Add to /etc/pf.conf:
block drop in proto tcp from any to any port 8080
pass in proto tcp from 127.0.0.1 to any port 8080
```

### TLS/HTTPS

Use a reverse proxy for TLS termination:

```bash
# Caddy (automatic HTTPS)
caddy reverse-proxy --from era-agent.example.com --to localhost:8080

# Nginx with Let's Encrypt
sudo certbot --nginx -d era-agent.example.com
```

## Monitoring

### Health Checks

There is no specific health check endpoint in the current implementation. You can check the VM list endpoint:

```bash
#!/bin/bash
# health-check.sh

RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/api/vm/list)

if [ "$RESPONSE" -eq 200 ]; then
    echo "ERA Agent: OK"
    exit 0
else
    echo "ERA Agent: FAILED (HTTP $RESPONSE)"
    exit 1
fi
```

### Prometheus Metrics

Add metrics endpoint wrapper:

```python
from prometheus_client import Counter, Histogram, generate_latest
from flask import Flask, Response
import requests
import time

app = Flask(__name__)

request_count = Counter('era_requests_total', 'Total requests')
request_duration = Histogram('era_request_duration_seconds', 'Request duration')

@app.route('/api/<path:path>', methods=['POST'])
def proxy(path):
    request_count.inc()

    start = time.time()
    response = requests.post(
        f'http://localhost:8080/api/{path}',
        json=request.json
    )
    request_duration.observe(time.time() - start)

    return response.json()

@app.route('/metrics')
def metrics():
    return Response(generate_latest(), mimetype='text/plain')
```

### Logging

Structured JSON logging:

```bash
# Run with JSON logs
AGENT_LOG_LEVEL=info ./agent server 2>&1 | jq -R 'fromjson? | .'

# Log to file
./agent server >> /var/log/era-agent.log 2>&1

# Rotate logs
logrotate -f /etc/logrotate.d/era-agent
```

## Performance Tuning

### Concurrent Connections

The server handles concurrent requests. Monitor with:

```bash
# Check open connections
netstat -an | grep 8080 | wc -l

# Check process resources
top -p $(pgrep agent)
```

### Resource Limits

Set system limits:

```bash
# /etc/security/limits.conf
era-agent soft nofile 4096
era-agent hard nofile 8192
```

### Load Balancing

Run multiple instances behind a load balancer:

```nginx
upstream era_agent {
    server 127.0.0.1:8080;
    server 127.0.0.1:8081;
    server 127.0.0.1:8082;
}

server {
    location / {
        proxy_pass http://era_agent;
    }
}
```

Start multiple instances:

```bash
PORT=8080 ./agent server &
PORT=8081 ./agent server &
PORT=8082 ./agent server &
```

## Troubleshooting

### Port Already in Use

```bash
# Find what's using the port
lsof -i :8080

# Kill the process
kill $(lsof -t -i:8080)

# Or use different port
PORT=9000 ./agent server
```

### Permission Denied

```bash
# Use port > 1024 (no sudo needed)
PORT=8080 ./agent server

# Or give binary permission to bind to port 80
sudo setcap CAP_NET_BIND_SERVICE=+eip ./agent
./agent server  # Can now use PORT=80
```

### Connection Refused

```bash
# Check if server is running
curl http://localhost:8080/api/vm/list

# Check firewall
sudo iptables -L -n | grep 8080

# Check if listening
netstat -tulpn | grep 8080
```

## Comparison: Local vs Cloudflare Workers

| Feature | Local HTTP Server | Cloudflare Workers |
|---------|------------------|-------------------|
| **Setup** | One command | Deploy with Wrangler |
| **Cost** | Free (your hardware) | Pay per request |
| **Latency** | Local (fastest) | Global edge network |
| **Scaling** | Manual | Automatic |
| **Customization** | Full control | Limited |
| **Auth** | Built-in ERA_API_KEY | Built-in options |
| **Best For** | Self-hosted, dev/test | Production, scale |

## Next Steps

- [API Reference](/docs/api-reference) - Complete API documentation
- [CLI Usage](/docs/local/cli-usage) - Command-line interface
- [MCP Server](/docs/local/mcp-server) - Claude Desktop integration
- [Docker Deployment](/docs/local/docker-deployment) - Containerized deployment
